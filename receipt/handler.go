package receipt

import (
	"context"
	"errors"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/stackup-wallet/stackup-bundler/pkg/entrypoint"
	"github.com/stackup-wallet/stackup-bundler/pkg/entrypoint/filter"
)

// UserOperationReceipt represents the receipt of a UserOperation along with accompanying transaction details.
// It includes metadata like the hash, sender, paymaster, nonce, gas usage, and custom reasons for failure.
type UserOperationReceipt struct {
	UserOpHash    common.Hash        `json:"userOpHash"`    // Hash of the UserOperation
	Sender        common.Address     `json:"sender"`        // Address of the sender of the UserOperation
	Paymaster     common.Address     `json:"paymaster"`     // Address of the paymaster, if any
	Nonce         string             `json:"nonce"`         // Nonce of the UserOperation
	Success       bool               `json:"success"`       // Success status of the UserOperation
	ActualGasCost string             `json:"actualGasCost"` // Actual gas cost incurred
	ActualGasUsed string             `json:"actualGasUsed"` // Actual gas used during execution
	From          common.Address     `json:"from"`          // Sender of the transaction
	Receipt       *parsedTransaction `json:"receipt"`       // Details of the associated transaction
	Logs          []*types.Log       `json:"logs"`          // Logs emitted during execution
	// adding `reason` key which is missing in stackup implementation
	// https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/schemas/receipt.yaml#L139
	// Borsa Network Bundler will be using this key to maintain the status of the userop.
	Reason string `json:"reason,omitempty"` // Optional reason for failure or additional status information
}

// parsedTransaction represents the parsed details of an Ethereum transaction.
type parsedTransaction struct {
	BlockHash         common.Hash    `json:"blockHash"`         // Hash of the block containing the transaction
	BlockNumber       string         `json:"blockNumber"`       // Block number in hexadecimal format
	From              common.Address `json:"from"`              // Address of the transaction sender
	CumulativeGasUsed string         `json:"cumulativeGasUsed"` // Total gas used up to this transaction in the block
	GasUsed           string         `json:"gasUsed"`           // Gas used by this specific transaction
	Logs              []*types.Log   `json:"logs"`              // Logs generated by the transaction
	LogsBloom         types.Bloom    `json:"logsBloom"`         // Logs bloom filter
	TransactionHash   common.Hash    `json:"transactionHash"`   // Hash of the transaction
	TransactionIndex  string         `json:"transactionIndex"`  // Transaction index in the block
	EffectiveGasPrice string         `json:"effectiveGasPrice"` // Effective gas price used for the transaction
}

// GetUserOpReceiptFunc is a general interface for fetching a UserOperationReceipt given a userOpHash,
// EntryPoint address, and block range.
type GetUserOpReceiptFunc = func(hash string, ep common.Address, blkRange uint64) (*UserOperationReceipt, error)

// GetUserOpReceiptWithEthClient returns an implementation of GetUserOpReceiptFunc that relies on an eth
// client to fetch a UserOperationReceipt.
func GetUserOpReceiptWithEthClient(eth *ethclient.Client) GetUserOpReceiptFunc {
	return func(hash string, ep common.Address, blkRange uint64) (*UserOperationReceipt, error) {
		return GetUserOperationReceipt(eth, hash, ep, blkRange)
	}
}

// GetUserOperationReceipt retrieves the receipt for a specific UserOperation based on its hash.
// It filters the EntryPoint contract for UserOperationEvents and extracts associated transaction details.
func GetUserOperationReceipt(
	eth *ethclient.Client,
	userOpHash string,
	entryPoint common.Address,
	blkRange uint64,
) (*UserOperationReceipt, error) {
	// Validate the provided UserOperation hash
	if !filter.IsValidUserOpHash(userOpHash) {
		//lint:ignore ST1005 This needs to match the bundler test spec.
		return nil, errors.New("Missing/invalid userOpHash")
	}

	// Filter the UserOperationEvent from the EntryPoint contract
	it, err := filterUserOperationEvent(eth, userOpHash, entryPoint, blkRange)
	if err != nil {
		return nil, err
	}

	// Process the filtered event and retrieve associated transaction details
	if it.Next() {
		receipt, err := eth.TransactionReceipt(context.Background(), it.Event.Raw.TxHash)
		if err != nil {
			return nil, err
		}
		tx, isPending, err := eth.TransactionByHash(context.Background(), it.Event.Raw.TxHash)
		if err != nil {
			return nil, err
		} else if isPending {
			return nil, nil
		}
		from, err := types.Sender(types.LatestSignerForChainID(tx.ChainId()), tx)
		if err != nil {
			return nil, err
		}

		txnReceipt := &parsedTransaction{
			BlockHash:         receipt.BlockHash,
			BlockNumber:       hexutil.EncodeBig(receipt.BlockNumber),
			From:              from,
			CumulativeGasUsed: hexutil.EncodeBig(big.NewInt(0).SetUint64(receipt.CumulativeGasUsed)),
			GasUsed:           hexutil.EncodeBig(big.NewInt(0).SetUint64(receipt.GasUsed)),
			Logs:              receipt.Logs,
			LogsBloom:         receipt.Bloom,
			TransactionHash:   receipt.TxHash,
			TransactionIndex:  hexutil.EncodeBig(big.NewInt(0).SetUint64(uint64(receipt.TransactionIndex))),
			EffectiveGasPrice: hexutil.EncodeBig(tx.GasPrice()),
		}
		return &UserOperationReceipt{
			Reason:        "UserOperation executed successfully",
			UserOpHash:    it.Event.UserOpHash,
			Sender:        it.Event.Sender,
			Paymaster:     it.Event.Paymaster,
			Nonce:         hexutil.EncodeBig(it.Event.Nonce),
			Success:       it.Event.Success,
			ActualGasCost: hexutil.EncodeBig(it.Event.ActualGasCost),
			ActualGasUsed: hexutil.EncodeBig(it.Event.ActualGasUsed),
			From:          from,
			Receipt:       txnReceipt,
			Logs:          []*types.Log{&it.Event.Raw},
		}, nil
	}

	// Return nil if no matching events are found
	return nil, nil
}

// filterUserOperationEvent filters UserOperationEvents emitted by the EntryPoint contract within a specified block range.
// It returns an iterator to traverse the filtered events.
// https://github.com/stackup-wallet/stackup-bundler/blob/f145dfd14d12956176b48b80c50d6cb44a93ca49/pkg/entrypoint/filter/event.go#L13
func filterUserOperationEvent(
	eth *ethclient.Client,
	userOpHash string,
	entryPoint common.Address,
	blkRange uint64,
) (*entrypoint.EntrypointUserOperationEventIterator, error) {
	// Create a new EntryPoint instance
	ep, err := entrypoint.NewEntrypoint(entryPoint, eth)
	if err != nil {
		return nil, err
	}

	// Retrieve the latest block number
	bn, err := eth.BlockNumber(context.Background())
	if err != nil {
		return nil, err
	}

	// Calculate the block range for filtering
	toBlk := big.NewInt(0).SetUint64(bn)
	startBlk := big.NewInt(0)
	subBlkRange := big.NewInt(0).Sub(toBlk, big.NewInt(0).SetUint64(blkRange))
	if subBlkRange.Cmp(startBlk) > 0 {
		startBlk = subBlkRange
	}

	// Filter UserOperationEvents within the block range
	return ep.FilterUserOperationEvent(
		&bind.FilterOpts{Start: startBlk.Uint64()},
		[][32]byte{common.HexToHash(userOpHash)},
		[]common.Address{},
		[]common.Address{},
	)
}
